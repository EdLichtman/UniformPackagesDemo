<Project>
      <!--
  To use, add the PackageVersion or ExactVersion attribute to the <ProjectReference>
  i.e.
  <ItemGroup>
      <ProjectReference Include="..\..\ProjectA\ProjectA.csproj" ExactVersion="true"/>
      <ProjectReference Include="..\..\ProjectB\ProjectB.csproj" PackageVersion="[1.*,2)"/>
  </ItemGroup>
  
  ExactVersion will say that if we're packaging ProjectC and it has a dependency on ProjectA at ExactVersion, 
  then whatever the version ProjectA is at the time that we generate our nuspec file will be the exact version (no more, no less). 
  Useful if we want to ensure something like Model/Persistence where you can't bump one without the other.
  
  PackageVersion allows you to specify a minimum/maximum. Normally when working projectReference, it only specifies a Minimum required version, 
  but this way we can do something like PackageVersion="[@(PackageVersion),2.*)" to say that the "minimum" is whatever the current package version is, 
  but once you hit the next version, we won't allow you to use this package.
  -->
  <Target Name="UseExplicitPackageVersions" BeforeTargets="GenerateNuspec">
    <ItemGroup>
      <_ProjectReferenceWithExplicitPackageVersion Include="@(ProjectReference->'%(FullPath)')" Condition="'%(ProjectReference.PackageVersion)' != ''" />
      <_ProjectReferenceWithExactPackageVersion Include="@(ProjectReference->'%(FullPath)')" Condition="'%(ProjectReference.ExactVersion)' == 'true'" />
      <_ProjectReferenceWithReassignedVersion Include="@(_ProjectReferencesWithVersions)" Condition="'%(Identity)' != '' And '@(_ProjectReferenceWithExplicitPackageVersion)' == '@(_ProjectReferencesWithVersions)'">
        <ProjectVersion>@(_ProjectReferenceWithExplicitPackageVersion->'%(PackageVersion)')</ProjectVersion>
      </_ProjectReferenceWithReassignedVersion>
      <_ProjectReferenceWithReassignedVersion Include="@(_ProjectReferencesWithVersions)" Condition="'%(Identity)' != '' And '@(_ProjectReferenceWithExactPackageVersion)' == '@(_ProjectReferencesWithVersions)'">
        <ProjectVersion>[@(_ProjectReferencesWithVersions->'%(ProjectVersion)')]</ProjectVersion>
      </_ProjectReferenceWithReassignedVersion>
      <_ProjectReferencesWithVersions Remove="@(_ProjectReferenceWithReassignedVersion)" />
      <_ProjectReferencesWithVersions Include="@(_ProjectReferenceWithReassignedVersion)" />
    </ItemGroup>
  </Target>

    <!-- These two together cause the Project References that are also Packages in a package to extend to the parent consuming the package. -->
    <PropertyGroup>
      <TargetsForTfmSpecificBuildOutput>$(TargetsForTfmSpecificBuildOutput);CopyProjectReferencesToPackage</TargetsForTfmSpecificBuildOutput>
    </PropertyGroup>
    <Target Name="CopyProjectReferencesToPackage" DependsOnTargets="ResolveReferences">
      <ItemGroup>
        <BuildOutputInPackage Include="@(ReferenceCopyLocalPaths->WithMetadataValue('ReferenceSourceTarget', 'ProjectReference'))" />
      </ItemGroup>
    </Target>

    <!-- For every PackageReference with Pack=true, we include the TargetPathWithTargetPlatformMoniker
       using a combination of these scripts -->
    <!-- https://til.cazzulino.com/msbuild/how-to-include-package-reference-files-in-your-nuget-package -->
    <!-- https://turnerj.com/blog/the-pain-points-of-csharp-source-generators -->
    <!-- Adds all DependencyTargetPaths for all dependencies so we don't have to list each one. -->
    <!-- <PropertyGroup>
        <GetTargetPathDependsOn>
            $(GetTargetPathDependsOn);GetDependencyTargetPaths
        </GetTargetPathDependsOn>
    </PropertyGroup> -->
    <Target 
      Name="AddGenerationTimeReferences" 
      BeforeTargets="GetTargetPathWithTargetPlatformMoniker"
      AfterTargets="ResolvePackageDependenciesForBuild"
      Outputs="%(ResolvedCompileFileDefinitions.NuGetPackageId)">
        <ItemGroup>
            <NuGetPackageId Include="@(ResolvedCompileFileDefinitions -> '%(NuGetPackageId)')" />
        </ItemGroup>
        <PropertyGroup>
            <NuGetPackageId>@(NuGetPackageId -&gt; Distinct())</NuGetPackageId>
        </PropertyGroup>
        <ItemGroup>
            <PackageReferenceDependency Include="@(PackageReference -> WithMetadataValue('Identity', $(NuGetPackageId)))"/>
        </ItemGroup>
        <ItemGroup>
          <PackableReferenceDependency Include="@(PackageReferenceDependency -> WithMetadataValue('Pack', 'true'))"/>
        </ItemGroup>
        <PropertyGroup>
          <PackableReferenceDependency>@(PackableReferenceDependency -&gt; Distinct())</PackableReferenceDependency>
        </PropertyGroup>
        <ItemGroup>
            <ResolvedPackableCompileFileDefinitions
              Include="@(ResolvedCompileFileDefinitions -&gt; WithMetadataValue('NuGetPackageId', '$(PackableReferenceDependency)'))" />
        </ItemGroup>
        <ItemGroup>
            <!-- <TargetPathWithTargetPlatformMoniker Include="@(ResolvedPackableCompileFileDefinitions)" IncludeRuntimeDependency="false" /> -->
            <None Include="@(ResolvedPackableCompileFileDefinitions)" Pack="true" PackagePath="analyzers/dotnet/cs" />
        </ItemGroup>
    </Target>
</Project>
