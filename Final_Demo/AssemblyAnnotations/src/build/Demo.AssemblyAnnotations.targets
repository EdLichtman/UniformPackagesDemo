<Project>

    <Target Name="AnnotatePackageAssembly" BeforeTargets="GenerateMSBuildEditorConfigFileCore">
      <PropertyGroup>
        <Authors>Edward Lichtman</Authors>
        <PackageId>$(MSBuildProjectName)</PackageId>
        <PackageTags>$(PackageTags);common lib,demo</PackageTags>
        <Copyright>Copyright Â© Edward Lichtman $([System.DateTime]::Now.ToString(`yyyy`))</Copyright>
      </PropertyGroup>
    </Target>

      <!--
  To use, add the PackageVersion or ExactVersion attribute to the <ProjectReference>
  i.e.
  <ItemGroup>
      <ProjectReference Include="..\..\ProjectA\ProjectA.csproj" ExactVersion="true"/>
      <ProjectReference Include="..\..\ProjectB\ProjectB.csproj" PackageVersion="[1.*,2)"/>
  </ItemGroup>
  
  ExactVersion will say that if we're packaging ProjectC and it has a dependency on ProjectA at ExactVersion, 
  then whatever the version ProjectA is at the time that we generate our nuspec file will be the exact version (no more, no less). 
  Useful if we want to ensure something like Model/Persistence where you can't bump one without the other.
  
  PackageVersion allows you to specify a minimum/maximum. Normally when working projectReference, it only specifies a Minimum required version, 
  but this way we can do something like PackageVersion="[@(PackageVersion),2.*)" to say that the "minimum" is whatever the current package version is, 
  but once you hit the next version, we won't allow you to use this package.
  -->
  <Target Name="UseExplicitPackageVersions" BeforeTargets="GenerateNuspec">
    <ItemGroup>
      <_ProjectReferenceWithExplicitPackageVersion Include="@(ProjectReference->'%(FullPath)')" Condition="'%(ProjectReference.PackageVersion)' != ''" />
      <_ProjectReferenceWithExactPackageVersion Include="@(ProjectReference->'%(FullPath)')" Condition="'%(ProjectReference.ExactVersion)' == 'true'" />
      <_ProjectReferenceWithReassignedVersion Include="@(_ProjectReferencesWithVersions)" Condition="'%(Identity)' != '' And '@(_ProjectReferenceWithExplicitPackageVersion)' == '@(_ProjectReferencesWithVersions)'">
        <ProjectVersion>@(_ProjectReferenceWithExplicitPackageVersion->'%(PackageVersion)')</ProjectVersion>
      </_ProjectReferenceWithReassignedVersion>
      <_ProjectReferenceWithReassignedVersion Include="@(_ProjectReferencesWithVersions)" Condition="'%(Identity)' != '' And '@(_ProjectReferenceWithExactPackageVersion)' == '@(_ProjectReferencesWithVersions)'">
        <ProjectVersion>[@(_ProjectReferencesWithVersions->'%(ProjectVersion)')]</ProjectVersion>
      </_ProjectReferenceWithReassignedVersion>
      <_ProjectReferencesWithVersions Remove="@(_ProjectReferenceWithReassignedVersion)" />
      <_ProjectReferencesWithVersions Include="@(_ProjectReferenceWithReassignedVersion)" />
    </ItemGroup>
  </Target>

    <!-- These two together cause the Project References that are also Packages in a package to extend to the parent consuming the package. -->
    <PropertyGroup>
      <TargetsForTfmSpecificBuildOutput>$(TargetsForTfmSpecificBuildOutput);CopyProjectReferencesToPackage</TargetsForTfmSpecificBuildOutput>
    </PropertyGroup>
    <Target Name="CopyProjectReferencesToPackage" DependsOnTargets="ResolveReferences">
      <ItemGroup>
        <BuildOutputInPackage Include="@(ReferenceCopyLocalPaths->WithMetadataValue('ReferenceSourceTarget', 'ProjectReference'))" />
      </ItemGroup>
    </Target>

<!--#Section:
  The following targets and includes allow you to copy assets from a dependent assembly with PackageReferenceAsset
  For example, if you want to add System.Text.Json to the /analyzers/dotnet/cs directory in the package, you'd add:
    <PackageReferenceAsset Include="System.Text.Json" PackagePath="analyzers/dotnet/cs" Dependency="compile"/>
-->
    <Target 
      Name="AddGenerationTimePackageAssets" 
      BeforeTargets="GetTargetPathWithTargetPlatformMoniker"
      AfterTargets="ResolvePackageDependenciesForBuild"
      Condition="@(PackageReferenceAsset -&gt; Count()) &gt; 0"
      Outputs="%(ResolvedCompileFileDefinitions.NuGetPackageId)">
      <!-- Find The current Package Reference -->
      <ItemGroup>
        <_NuGetPackageId Include="@(ResolvedCompileFileDefinitions -> '%(NuGetPackageId)')" />
      </ItemGroup>
      <!-- find the PackageId for that reference -->
      <PropertyGroup>
        <_NuGetPackageId>@(_NuGetPackageId -&gt; Distinct())</_NuGetPackageId>
      </PropertyGroup>
      <!-- Find the PackageReferenceAsset dependencies that match this NuGet Package Id  -->
      <ItemGroup>
        <_PackageReferenceAssetDependency Include="@(PackageReferenceAsset -> WithMetadataValue('Identity', $(_NuGetPackageId)))"/>
      </ItemGroup> 
      <PropertyGroup>
        <_PackageReferenceAssetDependencyCount>@(_PackageReferenceAssetDependency -&gt; Count())</_PackageReferenceAssetDependencyCount>
        <_ShouldPackageAsset>False</_ShouldPackageAsset>
        <_ShouldPackageAsset Condition="$(_PackageReferenceAssetDependencyCount) != 0">True</_ShouldPackageAsset>
      </PropertyGroup>
      <Error Condition= "'$(_ShouldPackageAsset)' == 'True' and '%(_PackageReferenceAssetDependency.Dependency)' != 'compile' " Text="'%(_PackageReferenceAssetDependency.Identity)' PackageReferenceAsset was included but Dependency was set to '%(_PackageReferenceAssetDependency.Dependency)'. This configuration is not yet supported."/>
      <!-- Resolve their path on disc for assets. -->
      <ItemGroup Condition=" '$(_ShouldPackageAsset)' == 'True' ">
        <_ResolvedPackableCompileFileDefinitions Include="@(ResolvedCompileFileDefinitions -&gt; WithMetadataValue('NuGetPackageId', '$(_NuGetPackageId)'))">
          <PackagePath>@(_PackageReferenceAssetDependency -&gt; '%(PackagePath)')</PackagePath>
        </_ResolvedPackableCompileFileDefinitions>
      </ItemGroup>
      <ItemGroup Condition=" '$(_ShouldPackageAsset)' == 'True' ">
        <!-- For Project References -->
        <TargetPathWithTargetPlatformMoniker Include="@(_ResolvedPackableCompileFileDefinitions)" IncludeRuntimeDependency="false" />
        <!-- For Package References -->
        <None 
          Include="%(_ResolvedPackableCompileFileDefinitions.Identity)" 
          Pack="true" 
          PackagePath="%(_ResolvedPackableCompileFileDefinitions.PackagePath)" 
          Visible="false"/>
      </ItemGroup>
    </Target>
    <Target
    Name="AddGenerationTimeProjectAssets" 
    BeforeTargets="GetTargetPathWithTargetPlatformMoniker"
    AfterTargets="AddGenerationTimePackageAssets"
    Condition="@(PackageReferenceAsset -&gt; Count()) &gt; 0">
      <!-- Find all package reference Assets and group them into a new Item -->
      <ItemGroup>
        <_ProjectReferenceAsset Include="@(PackageReferenceAsset)"/>
      </ItemGroup>
      <!-- Remove any where the Identity is part of Resolved Compile File Definitions -->
      <ItemGroup>
        <_ProjectReferenceAsset Remove="@(TargetPathWithTargetPlatformMoniker -&gt; '%(NuGetPackageId)')"></_ProjectReferenceAsset>
      </ItemGroup>
      <PropertyGroup>
        <_ProjectReferenceAssetDependencyCount>@(_ProjectReferenceAsset -&gt; Count())</_ProjectReferenceAssetDependencyCount>
        <_ShouldPackageAsset>False</_ShouldPackageAsset>
        <_ShouldPackageAsset Condition="$(_ProjectReferenceAssetDependencyCount) != 0">True</_ShouldPackageAsset>
      </PropertyGroup>
      <Error Condition= "'$(_ShouldPackageAsset)' == 'True' and '%(_ProjectReferenceAsset.Dependency)' != 'compile' " Text="'%(_ProjectReferenceAsset.Identity)' PackageReferenceAsset was included but Dependency was set to '%(_ProjectReferenceAsset.Dependency)'. This configuration is not yet supported."/>
      <ItemGroup Condition=" '$(_ShouldPackageAsset)' == 'True' ">
        <None 
          Condition=" '%(_ProjectReferenceAsset.Dependency)' == 'compile' " 
          Include="$(OutputPath)\**\%(_ProjectReferenceAsset.Identity).dll" 
          Pack="true" 
          PackagePath="%(_ProjectReferenceAsset.PackagePath)" 
          Visible="false"
        />
      </ItemGroup>
    </Target>
    <ItemGroup>
      <PackageReferenceAsset Update="*" Visible="false"/>
    </ItemGroup>
</Project>
